use: make pure-fn! [module] [ copy module parent ]

import: make pure-fn! [module words] [ copy (project module words) parent ]

functions: make context-chain! system

in functions [
   doc self "A module that adds some sugar over the creation of functions, and using functional patterns"
    fn: make pure-fn! [args body] [ make pure-fn! args body ]
    |>: :fn
    head: fn [series] [pick series 0]
    tail: fn [series] [slice series 1 length series]
    does: fn [block] [ fn [] block ]
    times: fn [n f] [
        map (iota n) :f
    ]
    thread: fn [arg fns] [
        f: fn [a :func] [ func a ]
        fold reduce fns :f arg
    ]
    map: fn [series f] [
        fold
            tail series
            (fn [acc curr] [ append acc (f curr) ])
            append [] (f head series)
    ]
    filter: fn [series f] [
        fold
            tail series
            (fn [acc curr] [
                if (f curr)
                    [ append acc curr ]
                    [ acc ]
             ])
             append [] head series
    ]
    not: |> [x] [ eq? x false ]
    even?: fn [x] [
        eq? (// x 2) 0
    ]
    odd?: fn [x] [
        eq? (even? x) false
    ]
]

sockets: make context-chain! system

in sockets [
   use functions [ 'fn ]
   doc self "A module that adds helper functions for interacting with socket-like contexts"
   send: (fn [context data] [
    in context (compose [ send (data) ])
   ])
   open: (fn [context] [
    in context [ open ]
   ])
   close: (fn [context] [
    in context [ close ]
   ])
]
