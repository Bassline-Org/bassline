use functions

cell: fn [aValue] [
    context [
        value: aValue
        update: fn [newVal] [
            in parent compose [
                value: (newVal)
                emit "changed" value
            ]
        ]
    ]
]

computed: fn [inputs body] [
    map inputs fn [input] [
        print input
        ;print current get input
    ]
]

current: fn [aCell] [
    get aCell 'value
]

update: fn [aCell newVal] [
    in aCell compose [ update (newVal) ]
]

a: cell 10
b: cell 20
c: cell 30

handleChange: fn [e] [
    in parent [
        update c + current a current b
    ]
]

once: fn [target kind f] [
    remove: on target kind fn [e] [
        f e
        remove
    ]
]
removeA: on a "changed" :handleChange
removeB: on b "changed" :handleChange
once a "changed" fn [e] [
    print concat "once: " e
]

update a 20
update b 30

print concat "A: " current a
print concat "B: " current b
print concat "C: " current c

print "--------------------------------"
print "Removing handlers..."
removeA
removeB

update a 40
update b 50
print concat "A: " current a
print concat "B: " current b
print concat "C: " current c

foo: fn [a] [
    print map a fn ['a] [ print a ]
]

foo [a b c]

;a 123

;"done"