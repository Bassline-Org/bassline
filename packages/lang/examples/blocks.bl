; Blocks in Bassline
; Blocks are the fundamental data structure (like arrays/lists)

; ========================================
; CREATING BLOCKS
; ========================================

; Empty block
empty: []

; Block of numbers
numbers: [1 2 3 4 5]

; Block of strings
names: ["Alice" "Bob" "Carol"]

; Mixed types in a block
mixed: [1 "hello" true none [nested block]]

; Block with expressions (not evaluated inside block)
expressions: [+ 5 3 * 2 4]
; This is a block containing: +, 5, 3, *, 2, 4 (not evaluated)

; Nested blocks
matrix: [
    [1 2 3]
    [4 5 6]
    [7 8 9]
]

; ========================================
; ACCESSING BLOCK ELEMENTS
; ========================================

; Get element at index (0-based)
items: ["a" "b" "c" "d"]
first: at items 0
; first is "a"

second: at items 1
; second is "b"

last: at items 3
; last is "d"

; Accessing nested blocks
data: [[1 2] [3 4] [5 6]]
row: at data 0
; row is [1 2]

value: at (at data 0) 1
; value is 2 (second element of first row)

; ========================================
; BLOCK LENGTH
; ========================================

; Get length of block
items: [1 2 3 4 5]
len: length items
; len is 5

empty-len: length []
; empty-len is 0

; ========================================
; MODIFYING BLOCKS
; ========================================

; Append to block
fruits: ["apple" "banana"]
append fruits "orange"
; fruits is now ["apple" "banana" "orange"]

; Append multiple items
numbers: [1 2]
append numbers 3
append numbers 4
append numbers 5
; numbers is [1 2 3 4 5]

; Building blocks dynamically
result: []
append result 10
append result 20
append result 30
; result is [10 20 30]

; ========================================
; SLICING BLOCKS
; ========================================

; Get slice of block (start, end)
items: [1 2 3 4 5 6 7 8 9 10]
subset: slice items 2 5
; subset is [3 4 5] (indices 2, 3, 4)

first-three: slice items 0 3
; first-three is [1 2 3]

last-three: slice items 7 10
; last-three is [8 9 10]

; ========================================
; ITERATING OVER BLOCKS
; ========================================

; Foreach over block
colors: ["red" "green" "blue"]
foreach color colors [
    print color
]

; Transform block elements
numbers: [1 2 3 4 5]
squared: foreach n numbers [
    * n n
]
; squared is [1 4 9 16 25]

; Filter block elements
scores: [85 92 78 65 95 88]
high-scores: foreach score scores [
    either (>= score 80) [
        score
    ] [
        none
    ]
]
; high-scores has values >= 80 and nones

; ========================================
; BLOCK OPERATIONS
; ========================================

; Counting elements
items: [1 2 3 4 5]
count: 0
foreach item items [
    count: + count 1
]
; count is 5

; Sum of elements
numbers: [10 20 30 40 50]
sum: 0
foreach n numbers [
    sum: + sum n
]
; sum is 150

; Finding maximum
values: [23 45 67 12 89 34]
max: at values 0
foreach v values [
    either (> v max) [
        max: v
    ] [
        none
    ]
]
; max is 89

; Finding minimum
min: at values 0
foreach v values [
    either (< v min) [
        min: v
    ] [
        none
    ]
]
; min is 12

; Concatenating blocks (manually)
a: [1 2 3]
b: [4 5 6]
combined: []
foreach item a [
    append combined item
]
foreach item b [
    append combined item
]
; combined is [1 2 3 4 5 6]

; ========================================
; NESTED BLOCKS
; ========================================

; Accessing nested structure
people: [
    ["Alice" 30 "Engineer"]
    ["Bob" 25 "Designer"]
    ["Carol" 35 "Manager"]
]

; Get first person
person1: at people 0
; person1 is ["Alice" 30 "Engineer"]

; Get first person's name
name1: at person1 0
; name1 is "Alice"

; Get first person's age
age1: at person1 1
; age1 is 30

; Iterate over nested structure
foreach person people [
    name: at person 0
    age: at person 1
    role: at person 2
    print name
]

; Extract column from nested blocks
ages: foreach person people [
    at person 1
]
; ages is [30 25 35]

; ========================================
; PRACTICAL EXAMPLES
; ========================================

; Example 1: Build a list of squares
squares: []
repeat 10 [
    i: length squares
    i: + i 1
    square: * i i
    append squares square
]
; squares is [1 4 9 16 25 36 49 64 81 100]

; Example 2: Reverse a block
original: [1 2 3 4 5]
reversed: []
len: length original
i: - len 1

while [>= i 0] [
    item: at original i
    append reversed item
    i: - i 1
]
; reversed is [5 4 3 2 1]

; Example 3: Filter even numbers
numbers: [1 2 3 4 5 6 7 8 9 10]
evens: foreach n numbers [
    remainder: % n 2
    either (= remainder 0) [
        n
    ] [
        none
    ]
]
; evens contains even numbers and nones

; Example 4: Create a range
start: 5
end: 15
range: []
current: start

while [<= current end] [
    append range current
    current: + current 1
]
; range is [5 6 7 8 9 10 11 12 13 14 15]

; Example 5: Group by property
data: [
    ["apple" "fruit"]
    ["carrot" "vegetable"]
    ["banana" "fruit"]
    ["broccoli" "vegetable"]
]

fruits: foreach item data [
    category: at item 1
    either (= category "fruit") [
        at item 0
    ] [
        none
    ]
]
; fruits contains fruit names and nones

; Example 6: Zip two blocks
names: ["Alice" "Bob" "Carol"]
ages: [30 25 35]
people: []
index: 0

while [< index (length names)] [
    name: at names index
    age: at ages index
    person: [name age]
    append people person
    index: + index 1
]
; people is [["Alice" 30] ["Bob" 25] ["Carol" 35]]

; Example 7: Flatten nested block (one level)
nested: [[1 2] [3 4] [5 6]]
flat: []

foreach sublist nested [
    foreach item sublist [
        append flat item
    ]
]
; flat is [1 2 3 4 5 6]

; Example 8: Remove duplicates (naive)
items: [1 2 2 3 3 3 4 4 5]
unique: []

foreach item items [
    ; Simple contains check
    found: false
    foreach u unique [
        either (= u item) [
            found: true
        ] [
            none
        ]
    ]

    either found [
        none
    ] [
        append unique item
    ]
]
; unique is [1 2 3 4 5]

; Example 9: Partition by condition
numbers: [1 2 3 4 5 6 7 8 9 10]
less-than-five: []
five-or-more: []

foreach n numbers [
    either (< n 5) [
        append less-than-five n
    ] [
        append five-or-more n
    ]
]
; less-than-five is [1 2 3 4]
; five-or-more is [5 6 7 8 9 10]

; Example 10: Table data structure
table: [
    ["Name" "Age" "City"]
    ["Alice" 30 "NYC"]
    ["Bob" 25 "LA"]
    ["Carol" 35 "SF"]
]

headers: at table 0
rows: slice table 1 (length table)

; Process each row
foreach row rows [
    name: at row 0
    age: at row 1
    city: at row 2
    print name
]
